---
title: "stage_6_estimate_biomass_change"
author: "Shahar Chaikin"
date: "2025-10-01"
output: html_document
---
Estimating population-level year_over_year biomass change

libraries
```{r}
library(tidyverse)
```

Load the cleaned biomass data
```{r}
pop_data=read_rds("cleaned_MEDITS.rds") %>% 
  rename(total_wgt_cpue_per_haul=total_biomass_kg_per_hour_per_haul)
```

##1) Using Fredston et al., 2023
###1.1) calculate mean and sum annual biomass
sum hauls within years
```{r}
annual_biomass=pop_data %>% 
  group_by(unique_h3_population,year) %>% 
  summarise(mean_annual_biomass=mean(total_wgt_cpue_per_haul) %>% 
                                round(digits = 3),
            sum_annual_biomass=sum(total_wgt_cpue_per_haul) %>% 
                                round(digits = 3),
            annual_hauls=n())
```

flag each year within a specific population group as isolated if it lacks both an immediate preceding and an immediate succeeding year in the dataset.
```{r}
annual_biomass_flagged <- annual_biomass %>%
  # 1. Group the data by the unique identifier
  group_by(unique_h3_population) %>%
  
  # 2. Check for the presence of a preceding or successive year
  #    The 'year' vector inside mutate() refers to the years only within the current group.
  mutate(
    # Check if (year - 1) is in the group's years OR if (year + 1) is in the group's years.
    has_neighbor = ((year - 1) %in% year) | ((year + 1) %in% year),
    
    # A year is 'isolated' if it does NOT have a neighbor.
    is_isolated = !has_neighbor
  ) %>%
  
  # 3. Remove the temporary 'has_neighbor' column and ungroup the data
  ungroup() %>%
  select(-has_neighbor)
```

This code chunk calculates the log biomass ratio between consecutive years for each population group, applying a small epsilon correction to zero values to avoid infinite results, and setting the ratio to NA for non-consecutive years.
```{r}
# Define the small increment value
epsilon <- 0.01

annual_biomass_ratio <- annual_biomass %>%
  # 1. Group the data by the unique identifier
  group_by(unique_h3_population) %>%
  
  # 2. Arrange by year to ensure correct lagged comparisons
  arrange(year) %>%
  
  # 3. Add the preceding year's biomass and check for consecutiveness
  mutate(
    # Get the biomass from the preceding year in the group
    prev_mean_biomass = lag(mean_annual_biomass),
    
    # Get the year from the preceding row in the group
    prev_year = lag(year),
    
    # Check if the current year is exactly one year after the previous row's year
    is_consecutive = (year - prev_year) == 1
  ) %>%
  
  # 4. Calculate the Log Biomass Ratio (t / t-1)
  #    Only calculate if the years are consecutive.
  mutate(
    # Use if_else to apply the correction and calculation only for consecutive years.
    log_biomass_ratio = if_else(
      is_consecutive,
      {
        # Apply epsilon correction to both numerator (t) and denominator (t-1)
        # to avoid log(0) which is -Inf, and division by zero.
        biomass_t = mean_annual_biomass + epsilon
        biomass_t_minus_1 = prev_mean_biomass + epsilon
        
        # Calculate log ratio: log(biomass_t / biomass_{t-1})
        log(biomass_t / biomass_t_minus_1)
      },
      # Assign NA if the years are not consecutive
      NA_real_
    ),
  year_of_mhw=year-1) %>%
  
  # 5. Clean up temporary columns and ungroup
  select(-prev_mean_biomass, -prev_year, -is_consecutive) %>%
  ungroup() %>% 
  drop_na() %>% 
  mutate(h3_id= sapply(str_split(unique_h3_population, "_"), "[[", 2),

    # Split the string by the underscore and take the 3rd element (species)
    species = sapply(str_split(unique_h3_population, "_"), "[[", 3))

annual_biomass_ratio$log_biomass_ratio %>% hist()

#write_rds(annual_biomass_ratio,"annual_biomass_ratio_medits.rds")
```

