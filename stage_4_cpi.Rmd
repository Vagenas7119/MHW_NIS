---
title: "current_weighted_distance"
author: "Shahar Chaikin"
date: "2025-10-10"
output: html_document
---

libraries
```{r}
library(tidyverse)
```

Data
Read yearly current data dating from 1/1/1987-1/1/2022
n: 46.129 w: -6.4959 s: 27.896 e: 37.039
uo = eastward sea water velocity (m/s)
vo =northward sea water velocity (m/s)

```{r}
currents=stars::read_ncdf(
  "copernicus_data_by_hexagon/currents/cmems_mod_med_phy-cur_my_4.2km_P1Y-m_1760095046500.nc") %>% 
  as_tibble() %>% 
  drop_na %>% 
  mutate(h3_id=h3jsr::point_to_cell(
    input = sf::st_as_sf(.,
                         coords = c("longitude", "latitude"),
                         crs = 4326),
    res = 3))

```

Median current velocity per h3
```{r}
currents_median=currents %>% 
  group_by(h3_id) %>% 
  summarise(median_eastern=median(as.numeric(uo)),
            median_northern=median(as.numeric(vo)))
```

plot eastern
```{r eval=FALSE, include=FALSE}
currents_median_e_sf <- currents %>%
  group_by(h3_id) %>%
  summarise(median_eastern=median(as.numeric(uo))) %>% 
  # Pass the entire data frame and specify the H3 column name
  h3jsr::cell_to_polygon(
    input = .,               # '.' refers to the incoming data frame
    simple = FALSE           # Recommended for a tidy output
  ) %>%
  # The output is now a proper sf object, so st_set_crs works
  sf::st_set_crs(4326)

# 3. Get Mediterranean Land Boundaries for Context
# Function from rnaturalearth
world <-rnaturalearth:: ne_countries(scale = "large", returnclass = "sf")

# 4. Create the ggplot map
eastern_map <- ggplot() +
    # Plot the H3 Hexagons
  geom_sf(
    data = currents_median_e_sf,
    # Fills the hexagons based on the 'sources' count
    aes(fill = median_eastern), 
    color = "black",     
    linewidth = 0.1,     
    alpha = 0.8          
  ) +
  # Add land boundaries first 
  geom_sf(data = world, fill = "antiquewhite", color = "black", linewidth = 0.1) +
  # Customize the color scale (from ggplot2 / viridis package, which tidyverse uses)
  scale_fill_viridis_c(
    name = "Eastward velocity (m/s)",
    option = "turbo"
  ) +
  # Set the map extent to focus on the Mediterranean Sea
  coord_sf(
    xlim = c(-6, 38),   
    ylim = c(26, 48),  
    expand = FALSE
  ) +
  # Apply a clean theme and labels
  labs(
    title = "A) Median eastern",
    x = "Longitude",
    y = "Latitude"
  ) +
  theme_bw() +
  theme(
# --- CHANGE IS HERE ---
 # Moves the legend inside the plot using (x, y) coordinates
legend.position = c(0.22, 0.17),
# Optional: Makes the legend background transparent
legend.background = element_rect(fill = "transparent", color = NA),
legend.key.size = unit(0.25, "cm"),
panel.grid.major = element_line(color = "skyblue", linewidth = 0.2),
    panel.background = element_rect(fill = "skyblue", color = NA) 
  )
eastern_map
```

plot northern
```{r eval=FALSE, include=FALSE}
currents_median_n_sf <- currents %>%
  group_by(h3_id) %>%
  summarise(median_northern=median(as.numeric(vo))) %>% 
  # Pass the entire data frame and specify the H3 column name
  h3jsr::cell_to_polygon(
    input = .,               # '.' refers to the incoming data frame
    simple = FALSE           # Recommended for a tidy output
  ) %>%
  # The output is now a proper sf object, so st_set_crs works
  sf::st_set_crs(4326)

# 3. Get Mediterranean Land Boundaries for Context
# Function from rnaturalearth
world <-rnaturalearth:: ne_countries(scale = "large", returnclass = "sf")

# 4. Create the ggplot map
northern_map <- ggplot() +
    # Plot the H3 Hexagons
  geom_sf(
    data = currents_median_n_sf,
    # Fills the hexagons based on the 'sources' count
    aes(fill = median_northern), 
    color = "black",     
    linewidth = 0.1,     
    alpha = 0.8          
  ) +
  # Add land boundaries first 
  geom_sf(data = world, fill = "antiquewhite", color = "black", linewidth = 0.1) +
  # Customize the color scale (from ggplot2 / viridis package, which tidyverse uses)
  scale_fill_viridis_c(
    name = "Northward velocity (m/s)",
    option = "turbo"
  ) +
  # Set the map extent to focus on the Mediterranean Sea
  coord_sf(
    xlim = c(-6, 38),   
    ylim = c(26, 48),  
    expand = FALSE
  ) +
  # Apply a clean theme and labels
  labs(
    title = "B) Median Northern",
    x = "Longitude",
    y = "Latitude"
  ) +
  theme_bw() +
  theme(
# --- CHANGE IS HERE ---
 # Moves the legend inside the plot using (x, y) coordinates
legend.position = c(0.22, 0.17),
# Optional: Makes the legend background transparent
legend.background = element_rect(fill = "transparent", color = NA),
legend.key.size = unit(0.25, "cm"),
panel.grid.major = element_line(color = "skyblue", linewidth = 0.2),
    panel.background = element_rect(fill = "skyblue", color = NA) 
  )
northern_map
```

Export
```{r eval=FALSE, include=FALSE}
e_n_maps=gridExtra::grid.arrange(
  eastern_map,
  northern_map,
  ncol = 1,
  nrow=2,
  layout_matrix = rbind(c(1),
                        c(2)))

e_n_maps
ggsave(filename ="e_n_maps_all.png" ,plot =e_n_maps ,device = "jpeg",units = "cm",width = 20,height = 20)
```

#1) candidate index - Directional Current Index (DCI)
Higher scores for hexagons with current directionality that aligns with the bearign from the Suez Canal mouth to the target hexagon.

 Step 1: Data Preparation and Centroid Calculation
```{r}
library(geosphere) # Good for calculating distances on a sphere

# The Suez Canal Source H3 ID
SOURCE_H3 <- "833e65fffffffff"

# --- Assuming 'currents_median' has columns: h3_id, median_eastern (uo), median_northern (vo) ---

# 1. Calculate Centroids for all hexagons
# The h3_to_point function gives the center latitude and longitude
h3_centroids <- currents_median %>%
  mutate(
    coords = h3jsr::cell_to_point(h3_id),
    lat = sapply(coords, function(x) x[2]),
    lon = sapply(coords, function(x) x[1]),
  ) %>%
  select(-coords)

# 2. Extract Source Coordinates - manually is better
# source_coords <- h3_centroids %>%
#   filter(h3_id == SOURCE_H3) %>%
#   select(lon, lat)

SOURCE_LAT <- 31.332367
SOURCE_LON <- 32.385074 
```
 
 Step 2: Calculate Dispersal Vector (D) and Euclidean Distance
```{r}
dci_data <- h3_centroids %>%
  rowwise() %>%
  mutate(
    # 1. Calculate Simple Euclidean Distance (d_Euclidean, in meters)
    d_Euclidean = geosphere::distm(c(SOURCE_LON, SOURCE_LAT), c(lon, lat), fun = geosphere::distHaversine),
    
    # 2. Calculate Bearing (direction of travel from source to target, in degrees)
    # This defines the direction of the Dispersal Vector (D)
    bearing_deg = geosphere::bearing(c(SOURCE_LON, SOURCE_LAT), c(lon, lat))
  ) %>%
  ungroup() %>%
  # Convert distance from meters to kilometers for a more manageable scale
  mutate(d_Euclidean_km = d_Euclidean / 1000) %>% 
  select(-d_Euclidean)
```
 
 Step 3: Calculate Current Assistance (Dot Product)
calculating the dot product to find the component of the current that aids (or opposes) travel along the direct line to the source.

Convert Bearing to Radians and Unit Vector: The bearing (direction of D) must be converted from degrees to radians, and then split into x (East/West) and y (North/South) components.

V = net Current Vector (V) - It is defined by the median current velocities extracted from the Copernicus data

D = Dispersal Vector (D) - represents the necessary direction of travel—the straight-line path from the Suez Canal source to the target hexagon.

Calculate Current Assistance (V⋅D):
```{r}
dci_data_step_3 <- dci_data %>%
  rowwise() %>%
  mutate(
    # Convert bearing to radians (standard unit of angular measure in mathematics; required for trigonometric functions)
    bearing_rad = bearing_deg * pi / 180,
    
    # 1. Calculate Dispersal Vector components (Dx and Dy)
    # The x-component is sine (East/West), y-component is cosine (North/South)
    # Note: Longitude/X is scaled by cos(latitude) for accuracy, but we use simple trig for the unit vector D
    Dx = sin(bearing_rad), #The x-component (East-West) is the side opposite the angle measured from North, which is defined by the sine function.
    # East-West component of the Dispersal path = 1 = complete east and -1 is full west component
    
    Dy = cos(bearing_rad), #The bearing is measured from North (0∘). The y-component (North-South) is therefore the adjacent side to the angle, which is defined by the cosine function.
    # North-South component of the Dispersal path = 1 = complete north, and -1 is full south component.
    
    # 2. Calculate Current Assistance (Dot Product: V . D)
    #The algebraic definition of the dot product (V⋅D):
    #East-West current component (median_eastern) with the East-West dispersal direction (Dx).
    #North-South current component (median_northern) with the North-South dispersal direction (Dy).
    # Assistance = (uo * Dx) + (vo * Dy)
    #In terms of units:
    #Current_Assistance=(m/s × unitless)+(m/s × unitless)
    Current_Assistance = (median_eastern * Dx) + (median_northern * Dy),
    
    # 3. Calculate Directional Current Index (DCI)
    # DCI = Current Assistance * Distance (km)
    DCI = Current_Assistance * d_Euclidean_km
  ) %>%
  ungroup() %>% 
  rowwise() %>%
  mutate(
    # Calculate the Distance Decay Penalty factor (the 0.01 or Lambda is a decay parameter that I can adjust)
#     λ (Decay Parameter): A positive constant that determines how quickly the resistance increases with distance.
# 
# Large λ: Fast decay (high resistance).
# 
# Small λ: Slow decay (low resistance).
    Distance_Decay_Penalty = exp(-0.001 * d_Euclidean_km),
    
    # Calculate the Distance-Penalized DCI (DCI_P)
    DCI_P = Current_Assistance * Distance_Decay_Penalty
  ) %>%
  ungroup()

#write.csv(dci_data_step_3,"dci_index.csv",row.names = F)

```

Explanation paragraph:
To accurately account for the non-random spatial spread of non-indigenous species (NIS) following the prevalent oceanographic regime, we developed a novel predictor variable: the Distance-Penalized Directional Current Index (DCI P). This index was incorporated into the GLMM to isolate the effect of physical dispersal mechanisms from general time trends. The DCI P was calculated for each h3 hexagon as the product of the Current Assistance and an Exponential Distance Decay Penalty. The Current Assistance component was derived from the dot product (V⋅D), where V is the local median current velocity vector (uo and vo) and D is the unit vector defining the straight-line path from the Suez Canal source hexagon to the target hexagon. This dot product yields a value in m/s that is positive when the local current assists travel toward the target, and negative when the current opposes it. This assistance value was then penalized using an exponential decay function, e (−λ×Distance km ) , where Distance km is the Euclidean distance from the source. This penalty ensures that the index heavily weights against long-distance dispersal, reflecting the inherent ecological resistance of colonization over great distances. Consequently, a positive DCI P value indicates a hexagon is highly favorable for colonization (supported by current and close to the source), while a negative DCI P  value indicates strong opposition from the current, typically observed in westward locations against the prevailing counter-clockwise circulation.


Interpretation of Directional Current Index (DCI)
Positive DCI: The hexagon's current field generally aligns with the straight-line path from the Suez Canal. This represents a favorable location for spread. (Expected for areas along the Levantine coast).

Negative DCI: The hexagon's current field generally opposes the straight-line path from the Suez Canal. This represents an unfavorable location for spread. (Expected for areas westward of the canal, like Libya).

Plot DCI_p
```{r}
dci_data_p_sf <- dci_data_step_3 %>%
  select(h3_id,DCI_P) %>% 
  # Pass the entire data frame and specify the H3 column name
  h3jsr::cell_to_polygon(
    input = .,               # '.' refers to the incoming data frame
    simple = FALSE           # Recommended for a tidy output
  ) %>%
  # The output is now a proper sf object, so st_set_crs works
  sf::st_set_crs(4326)

world <-rnaturalearth:: ne_countries(scale = "large", returnclass = "sf")

dci_p_map <- ggplot() +
    # Plot the H3 Hexagons
  geom_sf(
    data = dci_data_p_sf,
    # Fills the hexagons based on the 'sources' count
    aes(fill = DCI_P), 
    color = "black",     
    linewidth = 0.1,     
    alpha = 0.8          
  ) +
  # Add land boundaries first 
  geom_sf(data = world, fill = "antiquewhite", color = "black", linewidth = 0.1) +
  # Customize the color scale (from ggplot2 / viridis package, which tidyverse uses)
  # scale_fill_viridis_c(
  #   name = "Distance-penalized Directional Current Index",
  #   option = "turbo"
  # ) +
   scale_fill_gradient2(
    name = "Distance-penalized\nDirectional Current Index", # Use \n for clarity
    low = "blue",        # Color for negative values (opposition)
    mid = "white",       # Color for zero (neutrality/no effect)
    high = "red",        # Color for positive values (assistance)
    midpoint = 0,        # **Explicitly set the center of the scale to 0**
    limits = c(min(dci_data_p_sf$DCI_P), max(dci_data_p_sf$DCI_P)) # Ensure full range is used
  )+
  # Set the map extent to focus on the Mediterranean Sea
  coord_sf(
    xlim = c(-6, 38),   
    ylim = c(26, 48),  
    expand = FALSE
  ) +
  # Apply a clean theme and labels
  labs(
    x = "Longitude",
    y = "Latitude"
  ) +
  theme_bw() +
  theme(
# --- CHANGE IS HERE ---
 # Moves the legend inside the plot using (x, y) coordinates
legend.position = c(0.25, 0.17),
# Optional: Makes the legend background transparent
legend.background = element_rect(fill = "transparent", color = NA),
legend.key.size = unit(0.25, "cm"),
panel.grid.major = element_line(color = "skyblue", linewidth = 0.2),
    panel.background = element_rect(fill = "skyblue", color = NA) 
  )
dci_p_map
ggsave(filename ="dci_p_map_all.png" ,plot =dci_p_map ,device = "jpeg",units = "cm",width = 20,height = 12)
```


#ALTERNATIVE APPROACH - VAGENAS

```{r}

library(geosphere)
library(dplyr)
library(purrr)
library(h3jsr)

# The Suez Canal Source H3 ID
SOURCE_H3 <- "833e65fffffffff"
SOURCE_LAT <- 31.332367
SOURCE_LON <- 32.385074 

# Step 1: Simplified hexagon distance calculation using correct h3jsr functions
calculate_hexagon_distance_simple <- function(target_h3, source_h3) {
  max_rings <- 100  # Adjust based on your study area size
  
  for (k in 1:max_rings) {
    # Use get_disk from h3jsr - this is the correct function
    ring_hexagons <- h3jsr::get_disk(source_h3, k)[[1]]
    if (target_h3 %in% ring_hexagons) {
      return(k)  # Distance in hexagon steps
    }
  }
  return(Inf)  # Beyond max search distance
}

# Step 2: Calculate CPI components
cpi_data <- h3_centroids %>%
  rowwise() %>%
  mutate(
    # Component A: Inverted Path Distance through hexagons
    hex_distance = calculate_hexagon_distance_simple(h3_id, SOURCE_H3),
    A = 1 / (hex_distance + 0.001),  # Avoid division by zero
    
    # Calculate bearing for direction vector
    bearing_deg = geosphere::bearing(c(SOURCE_LON, SOURCE_LAT), c(lon, lat)),
    bearing_rad = bearing_deg * pi / 180,
    
    # Unit vector from reference to target (d̂_i)
    d_hat_x = sin(bearing_rad),
    d_hat_y = cos(bearing_rad)
  ) %>%
  ungroup()


#MAP

## The column name is h3_address, not h3_id
hexagons_with_vectors <- dci_data_step_3 %>%
  select(h3_id,DCI_P) %>% 
  # Pass the entire data frame and specify the H3 column name
  h3jsr::cell_to_polygon(
    input = .,               # '.' refers to the incoming data frame
    simple = FALSE           # Recommended for a tidy output
  ) %>%
  rename(h3_id=h3_address) %>% 
  # The output is now a proper sf object, so st_set_crs works
  sf::st_set_crs(4326) %>% #hexagons_sf %>% not sure what this is because it is not produced n this code.
  left_join(cpi_data %>% select(h3_id, d_hat_x, d_hat_y, bearing_deg, A), 
            by = "h3_id")

# Create arrow data for visualization
arrow_data <- hexagons_with_vectors %>%
  filter(!is.na(d_hat_x) & !is.na(d_hat_y)) %>%
  mutate(
    # Get centroid of each hexagon for arrow start point
    centroid = sf::st_centroid(geometry),
    centroid_coords = sf::st_coordinates(centroid),
    centroid_lon = centroid_coords[,1],
    centroid_lat = centroid_coords[,2],
    
    # Calculate arrow endpoints (scaled for visibility)
    arrow_scale = 0.2,  # Adjust this to change arrow length
    arrow_end_lon = centroid_lon + (d_hat_x * arrow_scale),
    arrow_end_lat = centroid_lat + (d_hat_y * arrow_scale)
  )

# Get world map
world <- rnaturalearth::ne_countries(scale = "large", returnclass = "sf")

# Create the direction vector map
direction_map <- ggplot() +
  # Plot hexagons colored by distance (Component A)
  geom_sf(
    data = hexagons_with_vectors,
    aes(fill = A), 
    color = "white",
    linewidth = 0.1,
    alpha = 0.7
  ) +
  # Add direction arrows
  geom_segment(
    data = arrow_data,
    aes(x = centroid_lon, y = centroid_lat, 
        xend = arrow_end_lon, yend = arrow_end_lat),
    arrow = arrow(length = unit(0.1, "cm"), type = "open"),
    color = "red",
    linewidth = 0.3
  ) +
  # Add reference point
  geom_point(aes(x = SOURCE_LON, y = SOURCE_LAT), 
             color = "darkred", size = 3, shape = 17) +
  annotate("text", x = SOURCE_LON, y = SOURCE_LAT + 0.5, 
           label = "Suez Canal\nReference", size = 3, hjust = 0.5) +
  
  # Add land boundaries
  geom_sf(data = world, fill = "antiquewhite", color = "black", linewidth = 0.1, alpha = 0.3) +
  
  # Color scale for distance
  scale_fill_viridis_c(
    name = "Component A\n(1/Distance)",
    option = "plasma"
  ) +
  
  # Map extent
  coord_sf(
    xlim = c(-6, 38),   
    ylim = c(26, 48),  
    expand = FALSE
  ) +
  
  # Labels and theme
  labs(
    title = "PARAMETER A: Inverted distance & Direction Vectors from Reference Hexagon",
    subtitle = "Arrows show direction from Suez Canal to each hexagon\nColor shows inverted distance (Component A)",
    x = "Longitude",
    y = "Latitude"
  ) +
  theme_bw() +
  theme(
    legend.position = "right",
    panel.grid.major = element_line(color = "skyblue", linewidth = 0.1),
    panel.background = element_rect(fill = "lightblue")
  )

print(direction_map)
# ggsave(filename ="direction_map_all.png" ,plot =direction_map ,device = "jpeg",units = "cm",width = 20,height = 12)

#Somthing is unintuitive in North Africa, the direction is Westward and not eastward
```
CALCULATE B parameter (current propagation index)
```{r}

# Calculate Component B with current propagation from Suez Canal
calculate_component_B_propagation <- function(all_hex_data) {
  
  # Get all hexagon distances from source for ordering
  hex_distances <- all_hex_data %>%
    select(h3_id, hex_distance) %>%
    arrange(hex_distance)
  
  # Initialize B values
  b_values <- setNames(rep(0, nrow(all_hex_data)), all_hex_data$h3_id)
  
  # Process hexagons in order of distance from source (closest first)
  for (dist in sort(unique(hex_distances$hex_distance))) {
    current_hexagons <- hex_distances %>% filter(hex_distance == dist) %>% pull(h3_id)
    
    for (hex_id in current_hexagons) {
      hex_data <- all_hex_data %>% filter(h3_id == hex_id)
      
      if (nrow(hex_data) == 1) {
        # For the source itself, use its own currents
        if (hex_id == SOURCE_H3) {
          # Dot product of source's own currents with its direction (should be 0 since no direction to itself)
          b_values[hex_id] <- 0
        } else {
          # Find hexagons that are closer to source and adjacent to current hexagon
          closer_hexagons <- hex_distances %>% 
            filter(hex_distance < dist) %>%
            pull(h3_id)
          
          # Get adjacent hexagons to current hexagon
          adjacent_ids <- h3jsr::get_disk(hex_id, 1)[[1]]
          
          # Filter to only keep adjacent hexagons that are closer to source
          relevant_adjacent <- intersect(adjacent_ids, closer_hexagons)
          
          if (length(relevant_adjacent) > 0) {
            # Calculate weighted average of B values from relevant adjacent hexagons
            adjacent_b_values <- numeric(0)
            adjacent_weights <- numeric(0)
            
            for (adj_id in relevant_adjacent) {
              adj_data <- all_hex_data %>% filter(h3_id == adj_id)
              
              if (nrow(adj_data) == 1) {
                # Calculate how well currents align between adjacent and current hexagon
                current_magnitude_adj <- sqrt(adj_data$median_eastern^2 + adj_data$median_northern^2)
                
                if (current_magnitude_adj > 0) {
                  # Normalize adjacent current vector
                  adj_vx <- adj_data$median_eastern / current_magnitude_adj
                  adj_vy <- adj_data$median_northern / current_magnitude_adj
                  
                  # Dot product: adjacent current ⋅ current hexagon direction
                  current_alignment <- (adj_vx * hex_data$d_hat_x) + (adj_vy * hex_data$d_hat_y)
                  
                  # Use the adjacent hexagon's B value weighted by current alignment
                  adjacent_b_values <- c(adjacent_b_values, b_values[adj_id] * current_alignment)
                  adjacent_weights <- c(adjacent_weights, abs(current_alignment))
                }
              }
            }
            
            # Calculate current hexagon's own current alignment
            current_magnitude <- sqrt(hex_data$median_eastern^2 + hex_data$median_northern^2)
            own_alignment <- 0
            if (current_magnitude > 0) {
              own_vx <- hex_data$median_eastern / current_magnitude
              own_vy <- hex_data$median_northern / current_magnitude
              own_alignment <- (own_vx * hex_data$d_hat_x) + (own_vy * hex_data$d_hat_y)
            }
            
            # Combine propagated B with own current alignment
            if (length(adjacent_b_values) > 0) {
              weighted_adj_b <- sum(adjacent_b_values * adjacent_weights) / sum(adjacent_weights)
              b_values[hex_id] <- 0.7 * weighted_adj_b + 0.3 * own_alignment  # Weighting
            } else {
              b_values[hex_id] <- own_alignment
            }
          } else {
            # No relevant adjacent hexagons, use own currents
            current_magnitude <- sqrt(hex_data$median_eastern^2 + hex_data$median_northern^2)
            if (current_magnitude > 0) {
              own_vx <- hex_data$median_eastern / current_magnitude
              own_vy <- hex_data$median_northern / current_magnitude
              b_values[hex_id] <- (own_vx * hex_data$d_hat_x) + (own_vy * hex_data$d_hat_y)
            }
          }
        }
      }
    }
  }
  
  return(b_values)
}

# Calculate Component B with propagation
b_propagation <- calculate_component_B_propagation(cpi_data)
cpi_data_with_B <- cpi_data %>%
  mutate(B = b_propagation[h3_id])

# Check the results
cat("=== PROPAGATION-BASED COMPONENT B STATISTICS ===\n")
summary(cpi_data_with_B$B)

# Detailed statistics
cat("\nDetailed B Statistics:\n")
cat("Range:", range(cpi_data_with_B$B), "\n")
cat("Mean:", mean(cpi_data_with_B$B), "\n")
cat("Median:", median(cpi_data_with_B$B), "\n")
cat("Standard Deviation:", sd(cpi_data_with_B$B), "\n")
cat("Positive values:", sum(cpi_data_with_B$B > 0), "/", nrow(cpi_data_with_B), "\n")
cat("Negative values:", sum(cpi_data_with_B$B < 0), "/", nrow(cpi_data_with_B), "\n")

# Visualize Component B with propagation
hexagons_with_B <- dci_data_step_3 %>%
  select(h3_id,DCI_P) %>% 
  # Pass the entire data frame and specify the H3 column name
  h3jsr::cell_to_polygon(
    input = .,               # '.' refers to the incoming data frame
    simple = FALSE           # Recommended for a tidy output
  ) %>%
  rename(h3_id=h3_address) %>% 
  # The output is now a proper sf object, so st_set_crs works
  sf::st_set_crs(4326) %>% #hexagons_sf %>%
  left_join(cpi_data_with_B %>% select(h3_id, B), 
            by = "h3_id")

# Create Component B propagation map
component_B_propagation_map <- ggplot() +
  geom_sf(
    data = hexagons_with_B,
    aes(fill = B), 
    color = "white",
    linewidth = 0.1,
    alpha = 0.8
  ) +
  geom_sf(data = world, fill = "antiquewhite", color = "black", linewidth = 0.1) +
  scale_fill_gradient2(
    name = "Component B\n(Propagated Current Alignment)",
    low = "blue",      # Negative values
    mid = "white",     # Neutral
    high = "red",      # Positive values
    midpoint = 0,
    na.value = "grey50"
  ) +
  geom_point(aes(x = SOURCE_LON, y = SOURCE_LAT), 
             color = "black", size = 2, shape = 20) +
  annotate("text", x = SOURCE_LON, y = SOURCE_LAT + 0.5, 
           label = "Suez Canal", size = 3, hjust = 0.5,vjust=3) +
  coord_sf(xlim = c(-6, 38), ylim = c(26, 48), expand = FALSE) +
  labs(
    title = "PARAMETER B: Propagated Current Alignment",
    subtitle = "Current alignment propagates from Suez Canal through adjacent hexagons",
    x = "Longitude",
    y = "Latitude"
  ) +
  theme_bw()+
  theme(
# --- CHANGE IS HERE ---
 # Moves the legend inside the plot using (x, y) coordinates
legend.position = c(0.25, 0.17),
# Optional: Makes the legend background transparent
legend.background = element_rect(fill = "transparent", color = NA),
legend.key.size = unit(0.25, "cm"),
panel.grid.major = element_line(color = "skyblue", linewidth = 0.2),
    panel.background = element_rect(fill = "skyblue", color = NA))

ggsave(filename ="component_B_propagation_map_all.png" ,plot =component_B_propagation_map ,device = "jpeg",units = "cm",width = 20,height = 12)
```


CALCULATE C (Decay parameter) AND SYNTHESIS OF CPI
```{r}


# Calculate Component C: Decay factor
# C = e^(-λ × A) where λ is a decay parameter

# Choose a lambda value - you can adjust this based on your needs
# Smaller lambda = slower decay, larger lambda = faster decay
lambda <- 4 #the best

# Calculate Component C
cpi_data_with_C <- cpi_data_with_B %>%
  mutate(
    # Component C: Exponential decay based on A and B
    C = exp(-lambda * A),
    
    # Final CPI: A × B × C
    CPI = A * B * C
  )


# Check all components
cat("=== ALL COMPONENTS SUMMARY ===\n")
cat("Component A (Inverted Distance):\n")
summary(cpi_data_with_C$A)
cat("\nComponent B (Propagated Current Alignment):\n")
summary(cpi_data_with_C$B)
cat("\nComponent C (Decay Factor):\n")
summary(cpi_data_with_C$C)
cat("\nFinal CPI:\n")
summary(cpi_data_with_C$CPI)

# Detailed CPI statistics
cat("\n=== FINAL CPI DETAILED STATISTICS ===\n")
cat("CPI Range:", range(cpi_data_with_C$CPI), "\n")
cat("CPI Mean:", mean(cpi_data_with_C$CPI), "\n")
cat("CPI Median:", median(cpi_data_with_C$CPI), "\n")
cat("CPI Standard Deviation:", sd(cpi_data_with_C$CPI), "\n")
cat("Positive CPI values:", sum(cpi_data_with_C$CPI > 0), "/", nrow(cpi_data_with_C), "\n")
cat("Negative CPI values:", sum(cpi_data_with_C$CPI < 0), "/", nrow(cpi_data_with_C), "\n")
cat("Zero CPI values:", sum(cpi_data_with_C$CPI == 0), "/", nrow(cpi_data_with_C), "\n")

# Visualize all components
hexagons_with_CPI <- dci_data_step_3 %>%
  select(h3_id,DCI_P) %>% 
  # Pass the entire data frame and specify the H3 column name
  h3jsr::cell_to_polygon(
    input = .,               # '.' refers to the incoming data frame
    simple = FALSE           # Recommended for a tidy output
  ) %>%
  rename(h3_id=h3_address) %>% 
  # The output is now a proper sf object, so st_set_crs works
  sf::st_set_crs(4326) %>%
  left_join(cpi_data_with_C %>% select(h3_id, A, B, CPI), 
            by = "h3_id")

#CPI map
cpi_map <- ggplot() +
  geom_sf(
    data = hexagons_with_CPI,
    aes(fill = CPI), 
    color = "white",
    linewidth = 0.1,
    alpha = 0.8
  ) +
  geom_sf(data = world, fill = "antiquewhite", color = "black", linewidth = 0.1) +
  scale_fill_gradient2(
    name = "CPI\n(Current Propagation Index)",
    low = "blue",      # Negative values
    mid = "white",     # Neutral
    high = "red",      # Positive values
    midpoint = 0,
    na.value = "grey50"
  ) +
  geom_point(aes(x = SOURCE_LON, y = SOURCE_LAT), 
             color = "black", size = 3, shape = 20) +
  annotate("text", x = SOURCE_LON, y = SOURCE_LAT + 0.5, 
           label = "Suez Canal", size = 3, hjust = 0.5,vjust=3) +
  coord_sf(xlim = c(-6, 38), ylim = c(26, 48), expand = FALSE) +
  labs(
    title = "Current Propagation Index (CPI)",
    subtitle = paste("CPI = A × B × C where C = exp(-λ × A), λ =", lambda),
    x = "Longitude",
    y = "Latitude"
  ) +
  theme_bw()+
  theme(
# --- CHANGE IS HERE ---
 # Moves the legend inside the plot using (x, y) coordinates
legend.position = c(0.25, 0.17),
# Optional: Makes the legend background transparent
legend.background = element_rect(fill = "transparent", color = NA),
legend.key.size = unit(0.25, "cm"),
panel.grid.major = element_line(color = "skyblue", linewidth = 0.2),
    panel.background = element_rect(fill = "skyblue", color = NA))

ggsave(filename ="component_B_propagation_map_dd_all.png" ,plot =cpi_map ,device = "jpeg",units = "cm",width = 20,height = 12)

write.csv(cpi_data_with_C,"cpi_data_with_C_all.csv",row.names = F)

# Show relationship between components
cat("\n=== COMPONENT RELATIONSHIPS ===\n")
cat("Correlation between A and B:", cor(cpi_data_with_C$A, cpi_data_with_C$B), "\n")
cat("Correlation between A and C:", cor(cpi_data_with_C$A, cpi_data_with_C$C), "\n")
cat("Correlation between B and C:", cor(cpi_data_with_C$B, cpi_data_with_C$C), "\n")
```
