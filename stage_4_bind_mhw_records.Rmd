---
title: "stage_4_bind_mhw_records"
author: "Shahar Chaikin"
date: "2025-09-24"
output: html_document
---

Bind climatologies with thinned records data

Libraries
```{r}
library(tidyverse)
```

#data
```{r}
#detrended
clim_dt=read_rds("climatology_dt_df.rds")
events_dt=read_rds("event_dt_df.rds")

#Records
records=read_csv("records data/cleaned/records_cleaned_harm_8_10_25.csv") %>% 
  #remove marmara and black sea records that are not in the climatic model
  filter(!h3_id%in%c("831ec8fffffffff", "831ec9fffffffff", "832d05fffffffff"))
```


#1) Spatially thin records
Use the first record within a hexagon across (1) all records and at the (2) species level
```{r}
#############
#All records#
#############
#For every h3_id, year,lat, and long keep only the first record
records_min=records %>% 
  group_by(h3_id,species) %>% 
  filter(year%in%min(year)) %>% 
 #For any remaining groups (h3_id/species) with multiple records in the minimum year, keep only the first one
  slice(1) %>%
#Ungroup the data (good practice after grouping operations)
  ungroup()

##################
#records_sp_level#
##################
records_min_sp_level=records %>% 
  group_by(h3_id,species) %>% 
  filter(year%in%min(year)) %>% 
 #For any remaining groups (h3_id/species) with multiple records in the minimum year, keep only the first one
  slice(1) %>%
#Ungroup the data (good practice after grouping operations)
  ungroup() %>% 
  group_by(h3_id,species,year) %>% 
  summarise(records=n()) %>% 
  rename(year_of_records=year)

#################################
#Sum annual and spatial records#
################################
records_min_count=records_min %>% 
  group_by(h3_id,year) %>% 
  summarise(records=n()) %>% 
  rename(year_of_records=year)
```

#2) detrended cumulative intensity
Estimate detrended annual cumulative intensity per hexagon
```{r}
annual_c_int_dt=clim_dt %>% 
  drop_na(residuals) %>% 
  mutate(
    # Create a new column, e.g., 'intensity'
    intensity = dplyr::if_else(
      !is.na(event_no), # The condition: is event_no not NA?
      residuals - seas, # What to do if the condition is TRUE
      0 # What to do if the condition is FALSE
    )) %>% 
    mutate(year_of_mhws=lubridate::year(date)) %>% 
  group_by(h3_id,year_of_mhws) %>% 
  summarise(annual_c_int=sum(intensity)) %>% 
  mutate(year_of_records=year_of_mhws+1)

#write_rds(annual_c_int_dt,"annual_c_int_dt.rds")
```

#3) Bind dt. MHWs and records
Bind MHWs with the records of the succeeding year

```{r}
# 1. Ungroup the MHW dataset first to avoid data structure errors
annual_c_int_ungrouped_dt <- annual_c_int_dt %>% 
  ungroup()

# Get all unique species per h3_id from the records data
h3_species_combo_dt <- records_min_sp_level %>%
  select(h3_id, species) %>%
  unique()

# Get the h3_id-year combinations along with annual_c_int_dt from the UNGROUPED MHW data
h3_year_combo_mhw_dt <- annual_c_int_ungrouped_dt %>%
  select(h3_id, year_of_mhws, annual_c_int, year_of_records) %>%
  unique()

# 2. Perform the joins to create the final dataset
final_data_clean_dt <- h3_year_combo_mhw_dt %>%
  
  # Cross-join MHW data with all species associated with that h3_id
  # This creates every combination of (h3_id, year, species)
  left_join(h3_species_combo_dt, by = "h3_id") %>%
  
  # Join with the records data to get the 'records' count (1 or NA)
  left_join(records_min_sp_level %>% select(h3_id, species, year_of_records, records), 
            by = c("h3_id", "species", "year_of_records")) %>%
  
  # Replace NA in records with 0
  mutate(records = replace_na(records, 0)) %>%
  
  # Ensure only the necessary columns remain and ordering is correct
  select(h3_id, species, year_of_mhws, annual_c_int, year_of_records, records) %>%
  
  # Ungroup again just to ensure the final output is a regular data frame
  ungroup()

####################################################################
#Now keep only mhw data preexisting to the species record in h3_id#
###################################################################
filtered_data_before_first_record_dt <- final_data_clean_dt %>%
  # 1. Group by the unique identifier pairs
  group_by(h3_id, species) %>%
  
  # 2. Arrange the data chronologically (important for finding the 'first' record)
  arrange(year_of_records, .by_group = TRUE) %>%
  
  # 3. Determine the year of the first record (records = 1)
  #    - If records exist (sum(records) > 0), find the earliest year where records == 1.
  #    - If no record exists for this h3_id/species, use the maximum year in the data
  #      to ensure all rows are kept (as there is no 'first record' to stop at).
  mutate(
    first_record_year = if_else(
      sum(records) > 0,
      min(year_of_records[records == 1]),
      max(year_of_records) # Keep all years if the species was never recorded
    )
  ) %>%
  
  # 4. Filter: keep rows where the year is less than or equal to the year of the
  #    first record.
  filter(year_of_records <= first_record_year) %>%
  
  # 5. Remove the helper column and ungroup
  select(-first_record_year) %>%
  ungroup() %>%
  filter(!is.na(species)) %>% 
  group_by(h3_id,species) %>%
  filter(sum(records)>0) %>% 
  ungroup()

#Check that there are no species with zero sum across hexagons and years
filtered_data_before_first_record_dt %>% 
  group_by(h3_id,species) %>% 
  summarise(sum=sum(records)) %>% view
```

#4) Additional variables

##4.1) Add sst (temporal and spatial)
```{r}
annual_sst=read_rds(
  "copernicus_data_by_hexagon/MEDSEA_MULTIYEAR_PHY_006_004_10m//corrected_hex_level_data/final_data/all_hexagons_daily_summary_10m.rds") %>%
  mutate(h3_id = str_remove(h3_id, "_cleaned"),
         year_of_mhws=lubridate::year(date)) %>% 
  group_by(h3_id,year_of_mhws) %>% 
             summarise(median_sst=median(mean_sst_10m))

sptaial_sst=read_rds(
  "copernicus_data_by_hexagon/MEDSEA_MULTIYEAR_PHY_006_004_10m//corrected_hex_level_data/final_data/all_hexagons_daily_summary_10m.rds") %>%
  mutate(h3_id = str_remove(h3_id, "_cleaned"),
         year_of_mhws=lubridate::year(date)) %>% 
  group_by(h3_id) %>% 
             summarise(median_s_sst=median(mean_sst_10m),
                       max_s_sst=max(mean_sst_10m),
                       min_s_sst=min(mean_sst_10m),
                       mean_s_sst=mean(mean_sst_10m))

#add the annual sst
filtered_data_before_first_record_dt_sst=filtered_data_before_first_record_dt %>% 
  left_join(annual_sst,by=c("h3_id","year_of_mhws")) %>% 
  left_join(sptaial_sst,by=c("h3_id"))
```

##4.2) Add monitoring effort proxy
Account for monitoring effort by years and h3_id
This specifically accounts for the increased monitoring effort over time
```{r}
#Proxy for monitoring effort
ormef <- read.delim("C:\\Users\\User\\Desktop\\research\\data\\ORMEF\\89476.tsv") %>% 
  mutate(
    # 1. str_replace() changes all commas (",") in the string to a period (".")
    Decimal_Lat = str_replace(Decimal_Lat, ",", "."),
    Decimal_Long = str_replace(Decimal_Long, ",", ".")) %>%
  # 2. Use a second mutate() call to convert the new string format to a numeric type
  mutate(
    Decimal_Lat = as.numeric(Decimal_Lat),
    Decimal_Long = as.numeric(Decimal_Long),
    h3_id = h3jsr::point_to_cell(
    input = sf::st_as_sf(.,
                         coords = c("Decimal_Long", "Decimal_Lat"),
                         crs = 4326),
    res = 3))# %>%  #keep all sources even if non Lessepsian related
 # filter(Category %in%"EXOTIC CAN")

#spatial monitoring effort for plotting
ormef_h3_id=ormef %>% 
  group_by(h3_id) %>% 
  summarise(sources=n_distinct(Reference))

#spatio-temporal monitoring effort for plotting
ormef_h3_id_year=ormef %>% 
  group_by(h3_id,Year) %>% 
  summarise(sources=n_distinct(Reference))
```

###bind to data
```{r}
#Find set of hexagons overlapping within ormef
h3_only_records=intersect(filtered_data_before_first_record_dt_sst$h3_id %>% unique(),
                          ormef_h3_id_year$h3_id %>% unique)

#add sources data
filtered_data_before_first_record_dt_sst_meff=
  filtered_data_before_first_record_dt_sst %>%
  filter(h3_id%in%h3_only_records) %>% 
  left_join(ormef_h3_id_year %>% 
              rename(year_of_records=Year),
            by=c("h3_id","year_of_records")) %>% 
  mutate(sources=case_when(is.na(sources)~0,
                           TRUE~sources))
```

Optional to add the predicted oremf sources within the data points after 2020 - however colinearity issues arise when using this.
```{r}
library(glmmTMB)
#####################################
#Consider  using the ORMEF data to predict sources across out study range
test_sources=glmmTMB(data=filtered_data_before_first_record_dt_sst_meff %>% 
                  filter(year_of_records%in%c(1988:2020)),
                formula = sources~year_of_records,
                family = "nbinom1")
#Model assesment
summary(test_sources)
#plot(DHARMa::simulateResiduals(test_sources))
performance::check_singularity(test_sources)
performance::check_convergence(test_sources)
MuMIn::r.squaredGLMM(test_sources)

#Extract predictions
test_sources_gg=ggeffects::ggpredict(test_sources,terms="year_of_records[1988:2020 by=1]") %>% 
  as_tibble() %>% 
  select(year_of_records=x,
         sources_pred=predicted,
         conf.low,
         conf.high)

#add predicted
filtered_data_before_first_record_dt_sst_meff=filtered_data_before_first_record_dt_sst_meff %>% 
  left_join(test_sources_gg %>% 
              select(year_of_records,
                     sources_pred),
            by="year_of_records") %>% 
  ungroup()
```

##4.3) Add year of first record
Species level variable
```{r}
year_of_f_rec=read.csv("records data/cleaned/records_cleaned_harm_8_10_25.csv") %>% 
  group_by(species) %>% 
  summarise(first_rec_year=min(year))

# add to the data
filtered_data_before_first_record_dt_sst_meff_yfr=filtered_data_before_first_record_dt_sst_meff %>% 
  left_join(year_of_f_rec,
            by="species") %>% 
  ungroup()
```

##4.4) CPI
```{r}
filtered_data_before_first_record_dt_sst_meff_yfr_cpi=
  filtered_data_before_first_record_dt_sst_meff_yfr %>% 
  left_join(read.csv("cpi_data_with_C_all.csv") %>% 
               select(h3_id,
                     CPI),
            by = join_by(h3_id)) %>% 
  ungroup()
```


#5) Removing false zeros in sources
```{r}
#Filter til 2020
filtered_data_before_first_record_dt_sst_meff_yfr_cpi_cleaned=
  filtered_data_before_first_record_dt_sst_meff_yfr_cpi %>% 
  filter(year_of_records<=2020)
  
#Now get rid of rows representing species with zero sum of records
check_zeros=filtered_data_before_first_record_dt_sst_meff_yfr_cpi_cleaned %>% 
  group_by(h3_id,species) %>% 
  summarise(n=(sum(records))) %>% 
  filter(n>0)
#applay cleaning on the data
filtered_data_before_first_record_dt_sst_meff_yfr_cpi_cleaned=
  filtered_data_before_first_record_dt_sst_meff_yfr_cpi_cleaned %>% 
  inner_join(check_zeros %>% select(-n),
             by=c("h3_id","species")) %>% 
  ungroup()
#make sure it is cleaned
filtered_data_before_first_record_dt_sst_meff_yfr_cpi_cleaned %>% 
  group_by(h3_id,species) %>% 
  summarise(n=(sum(records))) %>% 
  select(n) %>% 
  pull %>% 
  range
```

Save the data to be used for GLMMs
```{r}
write_rds(filtered_data_before_first_record_dt_sst_meff_yfr_cpi_cleaned,
          "record_data_for_glmms.rds")
```

#6) Plots
##6.1) records - points
```{r}
# Assuming your dataframe is named 'records'
# Ensure 'lat' and 'long' columns exist in 'records'

# 1. Get world map data
world_map <- rnaturalearth::ne_countries(scale = "large", returnclass = "sf")

# 2. Convert your 'records' data frame to an sf object
records_sf <- records_min %>%
  drop_na(lat, long) %>% # Remove rows with missing lat/long
  sf::st_as_sf(coords = c("long", "lat"), crs = 4326) # CRS 4326 is WGS84 for lat/long

# 3. Calculate the extent of your coordinates
bbox <- sf::st_bbox(records_sf)

# 4. Create the ggplot
rec_thinned_map=ggplot() +
  # Add the world map
  geom_sf(data = world_map, fill = "antiquewhite", color = "black", linewidth = 0.1) +
  # Add your data points
  geom_sf(data = records_sf, size = 1, alpha = 0.7) +
  # Crop the map to the extent of your points
  coord_sf(
    xlim = c(bbox["xmin"] - 1, bbox["xmax"] + 1), # Adjust buffer as needed
    ylim = c(bbox["ymin"] - 1, bbox["ymax"] + 1), # Adjust buffer as needed
    expand = FALSE # Prevents adding extra space around the crop
  ) +
  # Add labels and theme
  labs(
    title = "Species records (thinned)",
    x = "Longitude",
    y = "Latitude",
    color = "Species") +
  guides(color=F)+
  theme_bw() +
  theme(
# --- CHANGE IS HERE ---
 # Moves the legend inside the plot using (x, y) coordinates
legend.position = c(0.22, 0.17),
# Optional: Makes the legend background transparent
legend.background = element_rect(fill = "transparent", color = NA),
legend.key.size = unit(0.25, "cm"),
panel.grid.major = element_line(color = "skyblue", linewidth = 0.2),
    panel.background = element_rect(fill = "skyblue", color = NA))

# ggsave(filename ="rec_thinned_map.png" ,plot =rec_thinned_map ,device = "jpeg",units = "cm",width = 25,height = 12)
```

##6.2) used records - hexagons
```{r}
# 2. Convert H3 IDs to Spatial Polygons (sf object)
used_records_sf <- filtered_data_before_first_record_dt_sst_meff_yfr_cleaned %>%
  group_by(h3_id) %>%
  summarise(sum_records=sum(records)) %>% 
  # Pass the entire data frame and specify the H3 column name
  h3jsr::cell_to_polygon(
    input = .,               # '.' refers to the incoming data frame
    simple = FALSE           # Recommended for a tidy output
  ) %>%
  # The output is now a proper sf object, so st_set_crs works
  sf::st_set_crs(4326)

# 3. Get Mediterranean Land Boundaries for Context
# Function from rnaturalearth
world <-rnaturalearth:: ne_countries(scale = "large", returnclass = "sf")

# 4. Create the ggplot map
records_map <- ggplot() +
    # Plot the H3 Hexagons (your data)
  geom_sf(
    data = used_records_sf,
    # Fills the hexagons based on the 'sources' count
    aes(fill = sum_records), 
    color = "black",     
    linewidth = 0.1,     
    alpha = 0.8          
  ) +
  # Add land boundaries first 
  geom_sf(data = world, fill = "antiquewhite", color = "black", linewidth = 0.1) +
  # Customize the color scale (from ggplot2 / viridis package, which tidyverse uses)
  scale_fill_viridis_c(
    name = "Records",
    option = "turbo"
  ) +
  # Set the map extent to focus on the Mediterranean Sea
  coord_sf(
    xlim = c(-6, 38),   
    ylim = c(26, 48),  
    expand = FALSE
  ) +
  # Apply a clean theme and labels
  labs(
    title = "A) First records within the temoral range",
    x = "Longitude",
    y = "Latitude"
  ) +
  theme_bw() +
  theme(
# --- CHANGE IS HERE ---
 # Moves the legend inside the plot using (x, y) coordinates
legend.position = c(0.19, 0.89),
# Optional: Makes the legend background transparent
legend.background = element_rect(fill = "transparent", color = NA),
legend.key.size = unit(0.25, "cm"),
panel.grid.major = element_line(color = "skyblue", linewidth = 0.2),
    panel.background = element_rect(fill = "skyblue", color = NA))
```

##6.3) SST over time
```{r}
sst_time=filtered_data_before_first_record_dt_sst_meff_yfr_cleaned %>% 
  group_by(h3_id) %>% 
  distinct(h3_id,year_of_mhws,median_sst)
sst_time_p=ggplot(sst_time)+
  geom_point(aes(x=year_of_mhws,y=median_sst,color=median_sst),
             alpha=0.3)+
  geom_boxplot(aes(x=year_of_mhws,y=median_sst,group=year_of_mhws),
               alpha=0.2,notch=T,outliers = F)+
  geom_smooth(aes(x=year_of_mhws,y=median_sst),
              formula = y~x,method = "lm",se = F,color="black")+
  scale_color_viridis_c(
    name = "SST",
    option = "turbo"
  ) +
  labs(x="Years",y="Median SST (°C)",
       title="B) SST trend")+
  guides(color=F)+
  theme_bw()
sst_time_p
```

##6.4) Cumulative intensity over time
```{r}
c_int_time=filtered_data_before_first_record_dt_sst_meff_yfr_cleaned %>% 
  group_by(h3_id) %>% 
  distinct(h3_id,year_of_mhws,annual_c_int)

c_int_time_p=ggplot(c_int_time)+
  geom_point(aes(x=year_of_mhws,y=annual_c_int,color=annual_c_int),
             alpha=0.3)+
  geom_boxplot(aes(x=year_of_mhws,y=annual_c_int,group=year_of_mhws),
               alpha=0.2,notch=F,outliers = F)+
  scale_color_viridis_c(
    name = "Cumulative intensity",
    option = "turbo"
  ) +
  labs(x="Years",y="Cumulative intensity (°C-days)",
       title="C) MHWs detrended")+
  guides(color=F)+
  theme_bw()#+
  # theme(legend.position=c(0.85, 0.8),
  #       legend.background = element_blank(),
  #       legend.key.size = unit(0.4, 'cm'))
c_int_time_p
```

##6.5) Time series
```{r}
time_series=filtered_data_before_first_record_dt_sst_meff_yfr_cleaned %>% 
  group_by(h3_id,species) %>% 
  summarise(series_length=n())

time_series_sp=filtered_data_before_first_record_dt_sst_meff_yfr_cleaned %>% 
  group_by(species) %>% 
  summarise(distinct_series=n_distinct(h3_id))

#plot
time_series_p=ggplot(time_series)+
  geom_jitter(aes(x="",y=series_length),
              alpha=0.5,
              shape=21,
              fill="grey",
              size=0.3)+
  geom_violin(aes(x="",y=series_length),
              alpha=0.5,
              fill="grey")+
  geom_boxplot(aes(x="",y=series_length),
               outliers = F,
              width=0.3,
              fill="white")+
  theme_bw()+
  theme(axis.text.x = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_text(size=8,colour = "black", face = "bold"),
        plot.background = element_rect(fill = "transparent", color = NA),
        )+
  labs(y="Time series length (yrs.)")
time_series_p
```

Embed boxplot in map
```{r}
#embed sst
embeded_time_series_in_map <- records_map +
  annotation_custom(ggplotGrob(time_series_p),
                    xmin = -5, xmax = 9.5,
                    ymin = 26, ymax = 35)+
  theme(axis.title.y = element_blank())
embeded_time_series_in_map
```

Into grid
```{r}
intro_grid=gridExtra::grid.arrange(
  embeded_time_series_in_map,
  sst_time_p,
  c_int_time_p,
  ncol = 2,
  nrow=2,
  layout_matrix = rbind(c(1,1,1,1,1,1), # Row 1: P1 and P2
                        c(1,1,1,1,1,1),
                        c(1,1,1,1,1,1),
                        c(2,2,2,3,3,3),
                        c(2,2,2,3,3,3)))

ggsave(filename ="intro_grid.png" ,plot =intro_grid ,device = "jpeg",units = "cm",width = 20,height = 20)
```

##6.6) spatial SST
```{r}
# 2. Convert H3 IDs to Spatial Polygons (sf object)
sptaial_sst_sf <- sptaial_sst  %>% 
  # Pass the entire data frame and specify the H3 column name
  h3jsr::cell_to_polygon(
    input = .,               # '.' refers to the incoming data frame
    simple = FALSE           # Recommended for a tidy output
  ) %>%
  # The output is now a proper sf object, so st_set_crs works
  sf::st_set_crs(4326)

# 3. Get Mediterranean Land Boundaries for Context
# Function from rnaturalearth
world <-rnaturalearth:: ne_countries(scale = "large", returnclass = "sf")

# 4. Create the ggplot map
sst_map <- ggplot() +
    # Plot the H3 Hexagons (your data)
  geom_sf(
    data = sptaial_sst_sf,
    # Fills the hexagons based on the 'sources' count
    aes(fill = median_s_sst), 
    color = "black",     
    linewidth = 0.1,     
    alpha = 0.8          
  ) +
  # Add land boundaries first 
  geom_sf(data = world, fill = "antiquewhite", color = "black", linewidth = 0.1) +
  # Customize the color scale (from ggplot2 / viridis package, which tidyverse uses)
  scale_fill_viridis_c(
    name = "SST (°C)",
    option = "turbo"
  ) +
  # Set the map extent to focus on the Mediterranean Sea
  coord_sf(
    xlim = c(-6, 38),   
    ylim = c(26, 48),  
    expand = FALSE
  ) +
  # Apply a clean theme and labels
  labs(
    title = "A) Spatial SST",
    x = "Longitude",
    y = "Latitude"
  ) +
  theme_bw() +
  theme(
# --- CHANGE IS HERE ---
 # Moves the legend inside the plot using (x, y) coordinates
legend.position = c(0.15, 0.17),
# Optional: Makes the legend background transparent
legend.background = element_rect(fill = "transparent", color = NA),
legend.key.size = unit(0.25, "cm"),
panel.grid.major = element_line(color = "#DBDBDC", linewidth = 0.2),
    panel.background = element_rect(fill = "#DBDBDC", color = NA) 
  )
sst_map
```

##6.7) Spatial c_intensity
```{r}
spatial_c_int_dt=annual_c_int_dt  %>% 
  group_by(h3_id) %>% 
  select(h3_id,year_of_mhws,annual_c_int) %>% 
  summarise(max_c_int=max(annual_c_int))

# 2. Convert H3 IDs to Spatial Polygons (sf object)
spatial_c_int_dt_sf <- spatial_c_int_dt %>% 
  # Pass the entire data frame and specify the H3 column name
  h3jsr::cell_to_polygon(
    input = .,               # '.' refers to the incoming data frame
    simple = FALSE           # Recommended for a tidy output
  ) %>%
  # The output is now a proper sf object, so st_set_crs works
  sf::st_set_crs(4326)

# 3. Get Mediterranean Land Boundaries for Context
# Function from rnaturalearth
world <-rnaturalearth:: ne_countries(scale = "large", returnclass = "sf")

# 4. Create the ggplot map
max_c_int_map <- ggplot() +
    # Plot the H3 Hexagons (your data)
  geom_sf(
    data = spatial_c_int_dt_sf,
    # Fills the hexagons based on the 'sources' count
    aes(fill = max_c_int), 
    color = "black",     
    linewidth = 0.1,     
    alpha = 0.8          
  ) +
  # Add land boundaries first 
  geom_sf(data = world, fill = "antiquewhite", color = "black", linewidth = 0.1) +
  # Customize the color scale (from ggplot2 / viridis package, which tidyverse uses)
  scale_fill_viridis_c(
    name = "Max. cumulative intensity (°C-days)",
    option = "turbo"
  ) +
  # Set the map extent to focus on the Mediterranean Sea
  coord_sf(
    xlim = c(-6, 38),   
    ylim = c(26, 48),  
    expand = FALSE
  ) +
  # Apply a clean theme and labels
  labs(
    title = "B) Spatial cumulative intensity",
    x = "Longitude",
    y = "Latitude"
  ) +
  theme_bw() +
  theme(
# --- CHANGE IS HERE ---
 # Moves the legend inside the plot using (x, y) coordinates
legend.position = c(0.3, 0.17),
# Optional: Makes the legend background transparent
legend.background = element_rect(fill = "transparent", color = NA),
legend.key.size = unit(0.25, "cm"),
panel.grid.major = element_line(color = "#DBDBDC", linewidth = 0.2),
    panel.background = element_rect(fill = "#DBDBDC", color = NA) 
  )
max_c_int_map
```

Bind maps
```{r}
spatial_temp_panel=gridExtra::grid.arrange(
  sst_map,
  max_c_int_map,
  layout_matrix = rbind(c(1),
                        c(2)))
ggsave(filename ="spatial_temp_panel.png" ,plot =spatial_temp_panel ,device = "jpeg",units = "cm",width = 20,height = 20)
```

##6.8) monitoring effort control
```{r}
#plot
source_temp=ggplot(filtered_data_before_first_record_dt_sst_meff_yfr_cleaned %>% 
                     ungroup() %>% 
                     distinct(h3_id,year_of_records,sources))+
  geom_jitter(data=filtered_data_before_first_record_dt_sst_meff %>% 
                filter(year_of_records%in%c(1988:2020)),
              aes(x=year_of_records,y=sources),height = 0.1)+
  geom_ribbon(data=test_sources_gg,
              aes(x=year_of_records,
                  ymin=conf.low,
                  ymax=conf.high),
              alpha=0.5)+
  geom_line(data=test_sources_gg,
              aes(x=year_of_records,
                  y=sources_pred),linewidth=1,
            color="purple")+
  theme_bw()+
  labs(x="Year",y="Sources",title="B) Temporal trend")

```

##6.9) proxy to monitoring effort
```{r}
# 2. Convert H3 IDs to Spatial Polygons (sf object)
ormef_sf <- ormef_h3_id %>%
  filter(h3_id%in%intersect(filtered_data_before_first_record_dt_sst_meff_yfr_cleaned$h3_id %>% unique(),ormef_h3_id_year$h3_id %>% unique)) %>% 
  # Pass the entire data frame and specify the H3 column name
  h3jsr::cell_to_polygon(
    input = .,               # '.' refers to the incoming data frame
    simple = FALSE           # Recommended for a tidy output
  ) %>%
  # The output is now a proper sf object, so st_set_crs works
  sf::st_set_crs(4326)

# 3. Get Mediterranean Land Boundaries for Context
# Function from rnaturalearth
world <-rnaturalearth:: ne_countries(scale = "large", returnclass = "sf")

# 4. Create the ggplot map
h3_map <- ggplot() +
    # Plot the H3 Hexagons (your data)
  geom_sf(
    data = ormef_sf,
    # Fills the hexagons based on the 'sources' count
    aes(fill = sources), 
    color = "black",     
    linewidth = 0.1,     
    alpha = 0.8          
  ) +
  # Add land boundaries first 
  geom_sf(data = world, fill = "antiquewhite", color = "black", linewidth = 0.1) +
  # Customize the color scale (from ggplot2 / viridis package, which tidyverse uses)
  scale_fill_viridis_c(
    name = "Sources",
    option = "turbo"
  ) +
  # Set the map extent to focus on the Mediterranean Sea
  coord_sf(
    xlim = c(-6, 38),   
    ylim = c(26, 48),  
    expand = FALSE
  ) +
  # Apply a clean theme and labels
  labs(
    title = "A) Spatial distribution of sources",
    x = "Longitude",
    y = "Latitude"
  ) +
  theme_bw() +
  theme(
# --- CHANGE IS HERE ---
 # Moves the legend inside the plot using (x, y) coordinates
legend.position = c(0.22, 0.17),
# Optional: Makes the legend background transparent
legend.background = element_rect(fill = "transparent", color = NA),
legend.key.size = unit(0.25, "cm"),
panel.grid.major = element_line(color = "#DBDBDC", linewidth = 0.2),
    panel.background = element_rect(fill = "#DBDBDC", color = NA) 
  )
h3_map
```

bias grid
```{r}
bias_grid=gridExtra::grid.arrange(
  h3_map,
                        source_temp,
  layout_matrix = rbind(c(1, 1,1,1,1,1,1),
                        c(1, 1,1,1,1,1,1),
                        c(1, 1,1,1,1,1,1),# Row 1: P1 and P2
                        c(NA,2,2,2,2,2,NA),
                        c(NA,2,2,2,2,2,NA)))
ggsave(filename ="bias_grid.png" ,plot =bias_grid ,device = "jpeg",units = "cm",width = 20,height = 20)
```

##6.10) CPI
```{r}
# 2. Convert H3 IDs to Spatial Polygons (sf object)
ormef_sf <- filtered_data_before_first_record_dt_sst_meff_yfr_cpi_cleaned  %>% 
  distinct(h3_id,CPI) %>% 
  # Pass the entire data frame and specify the H3 column name
  h3jsr::cell_to_polygon(
    input = .,               # '.' refers to the incoming data frame
    simple = FALSE           # Recommended for a tidy output
  ) %>%
  # The output is now a proper sf object, so st_set_crs works
  sf::st_set_crs(4326)

# 3. Get Mediterranean Land Boundaries for Context
# Function from rnaturalearth
world <-rnaturalearth:: ne_countries(scale = "large", returnclass = "sf")

# 4. Create the ggplot map
cpi_map <- ggplot() +
    # Plot the H3 Hexagons (your data)
  geom_sf(
    data = ormef_sf,
    # Fills the hexagons based on the 'sources' count
    aes(fill = CPI), 
    color = "black",     
    linewidth = 0.1,     
    alpha = 0.8          
  ) +
  # Add land boundaries first 
  geom_sf(data = world, fill = "antiquewhite", color = "black", linewidth = 0.1) +
  # Customize the color scale (from ggplot2 / viridis package, which tidyverse uses)
  scale_fill_gradient2(
    name = "CPI (m/s)",
    low = "blue",      # Negative values
    mid = "white",     # Neutral
    high = "red",      # Positive values
    midpoint = 0,
    na.value = "grey50"
  ) +
  # Set the map extent to focus on the Mediterranean Sea
  coord_sf(
    xlim = c(-6, 38),   
    ylim = c(26, 48),  
    expand = FALSE
  ) +
  # Apply a clean theme and labels
  labs(
    x = "Longitude",
    y = "Latitude"
  ) +
  theme_bw() +
  theme(
# --- CHANGE IS HERE ---
 # Moves the legend inside the plot using (x, y) coordinates
legend.position = c(0.15, 0.17),
# Optional: Makes the legend background transparent
legend.background = element_rect(fill = "transparent", color = NA),
legend.key.size = unit(0.25, "cm"),
panel.grid.major = element_line(color = "#DBDBDC", linewidth = 0.2),
    panel.background = element_rect(fill = "#DBDBDC", color = NA) 
  )+
  geom_point(aes(x = 32.385074, y = 31.332367), 
             color = "black", size = 3, shape = 20) +
  annotate("text", x = 32.385074, y = 31.332367 + 0.5, 
           label = "Suez Canal", size = 3, hjust = 0.5,vjust=3)

ggsave(filename ="cpi_map.png" ,plot =cpi_map ,device = "jpeg",units = "cm",width = 20,height = 12)
```

