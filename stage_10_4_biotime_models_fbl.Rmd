---
title: "medits_models"
author: "Shahar Chaikin"
date: "2025-10-03"
output: html_document
---

libraries
```{r}
library(tidyverse)
library(glmmTMB)
library(broom.mixed)
```

data
```{r}
#Abundance
biotime_mhw_n=read_rds("biotime_mhw_n_fbl.rds")
biotime_mhw_n_nis=biotime_mhw_n %>% 
  filter(is_les%in%1)

pop_by_nis_n=biotime_mhw_n %>% 
  filter(is_les%in%1) %>% 
  group_by(species) %>% 
  summarise(n_pop=n_distinct(unique_h3_population),
            n_estimates=n(),
            n_dist_yr=n_distinct(year),
            n_dist_hex=n_distinct(h3_id))

biotime_mhw_n_nis=biotime_mhw_n_nis %>% 
  left_join(pop_by_nis_n %>%
              select(species,n_estimates),
            by="species") %>% 
  mutate(weights=log(n_estimates))
```

plot
```{r}
#Abundance
ggplot(data=biotime_mhw_n %>% 
                   filter(is_les%in%1))+
  geom_point(aes(x=annual_c_int,y=log_n_ratio ))

biotime_mhw_n$log_n_ratio %>% hist
```

#1) species-level
##1.1) Abundance
Setup and Model Fitting
```{r}
# Assuming 'biotime_mhw_n_nis' is already loaded and contains 'species', 
# 'log_n_ratio', 'annual_c_int', and 'weights'.

species_list_n <- biotime_mhw_n_nis$species %>% unique()
sp_test_n <- list()
failed_models <- character()
non_converged_models <- character() # NEW: List for models that failed convergence check

# 1. Model Fitting with Robust Error and Convergence Handling
for (i in species_list_n) {
  # Subset data for the current species
  data_sp <- biotime_mhw_n_nis %>%
    filter(species %in% i)

  # Check if there's enough data (optional but recommended)
  if (nrow(data_sp) < 2) {
    message(paste("Skipping", i, "due to insufficient data."))
    next
  }

  # Fit the model using tryCatch for robust error handling
  model_result <- tryCatch({
    glmmTMB(
      data = data_sp,
      formula = log_n_ratio ~ annual_c_int,
      family = gaussian, # Zero-inflation component
      weights = weights
    )
  }, error = function(e) {
    # If a hard error occurs during fitting, log the species and return NULL
    message(paste("Model failed (Hard Error) for species:", i, "Error:", e$message))
    failed_models <<- c(failed_models, i)
    return(NULL)
  })

  # Check convergence if the model fitted without a hard error
  if (!is.null(model_result)) {
    is_converged <- performance::check_convergence(model_result)

    if (is_converged) {
      # Store the successful and converged model
      sp_test_n[[i]] <- model_result
    } else {
      # Log the model that failed the convergence check
      message(paste("Model failed (Non-Convergence) for species:", i))
      non_converged_models <<- c(non_converged_models, i)
    }
  }
}

# Remove entries that are NULL (no longer strictly necessary after the check, 
# but good practice if model_result was ever stored outside the loop)
sp_test_n <- purrr::compact(sp_test_n)

# Summary of results
message(paste("\nSuccessfully fitted and **converged** models for", length(sp_test_n), "species."))
message(paste("Models failed due to Hard Error:", paste(failed_models, collapse = ", ")))
message(paste("Models excluded due to Non-Convergence:", paste(non_converged_models, collapse = ", ")))
```

Predicted Values Extraction
```{r}
# 2. Predicted Values Extraction (using ggeffects)
predicted_values_df <- sp_test_n %>%
  # map2_dfr is used to iterate over the models AND their names (species)
  purrr::map2_dfr(.x = ., .y = names(.),
    .f = function(model, species_name) {

      # Get min/max of annual_c_int for the current species
      species_data <- biotime_mhw_n_nis %>%
        filter(species %in% species_name)
      min_val <- min(species_data$annual_c_int, na.rm = TRUE)
      max_val <- max(species_data$annual_c_int, na.rm = TRUE)

      # Construct the terms argument
      terms_arg <- paste0("annual_c_int[", min_val, ":", max_val, " by = 1]")

      # Extract predicted values
      predictions <- ggeffects::ggpredict(model, terms = terms_arg) %>%
        as.data.frame() # Convert to standard dataframe

      # Rename and select required columns
      predictions %>%
        select(x = x, predicted = predicted, ci_low = conf.low, ci_high = conf.high) %>%
        # Add the species column
        mutate(species = species_name, .before = 1)
    }
  )

# Display the resulting dataframe (first few rows)
# head(predicted_values_df)
# dim(predicted_values_df)

# The requested dataframe is 'predicted_values_df'
```

Model Summary Extraction
```{r}
# 3. Model Summary Extraction (using broom.mixed::tidy) - REVISED
model_summary_df <- sp_test_n %>%
  # map_dfr iterates over the models and combines the output into a single dataframe
  purrr::map_dfr(
    .f = function(model) {
      # Extract summary using tidy()
      summary_data <- broom.mixed::tidy(model, effects = "fixed")

      # Filter for the 'annual_c_int' term
      summary_data %>%
        filter(term == "annual_c_int") %>%
        # Select and rename columns: estimate (coefficient), t-value, p.value
        select(
          term,
          coefficient = estimate, # ADDED: The slope/coefficient
          z_value = statistic,
          p_value = p.value
        ) %>%
        # Add a column for the number of observations (n)
        mutate(n = nobs(model))
    },
    .id = "species" # Add a column identifying the list element name (species name)
  )

# Display the resulting dataframe (first few rows)
# head(model_summary_df)
# dim(model_summary_df)

# The requested dataframe is 'model_summary_df'
```

#2) all species

##2.2) abundance
```{r}
biotime_mhw_n_cat=biotime_mhw_n %>% 
  mutate(mhw_cat=case_when(annual_c_int>40~"moderate",
                           annual_c_int<40 & annual_c_int>0~"mild",
                           annual_c_int==0~"normal"))

biotime_mhw_n_cat$mhw_cat=factor(x = biotime_mhw_n_cat$mhw_cat,
                                levels = c("normal", "mild" , "moderate"))

test_nis_n=lm(data=biotime_mhw_n_cat,
             formula = log_n_ratio~mhw_cat*is_les)
plot(DHARMa::simulateResiduals(test_nis_n))
summary(test_nis_n)
performance::check_convergence(test_nis_n)
performance::check_singularity(test_nis_n)
MuMIn::r.squaredGLMM(test_nis_n)
sjPlot::plot_model(test_nis_n,type="eff",terms = c("mhw_cat","is_les"))

#predict
test_nis_n_gg=ggeffects::ggpredict(test_nis_n,terms="annual_c_int[0:145 by=1]")
```

#3) Plot
Abudnance
```{r}
abundance_ratios=ggplot()+
  geom_rug(data=biotime_mhw_n_nis,
           aes(x=annual_c_int,y=log_n_ratio))+
  geom_hline(yintercept = 0,linetype="dashed",color="grey")+
  geom_line(data=predicted_values_df,
            aes(x=x,y=predicted,color=species),alpha=0.3)+
  geom_ribbon(data=test_nis_n_gg,
              aes(x=x,ymin=conf.low,ymax=conf.high),alpha=0.3)+
  geom_line(data=test_nis_n_gg,
            aes(x=x,y=predicted),
            linewidth=1)+
  coord_cartesian(ylim=c(-9.5,9.5))+
  theme_bw()+
  labs(x="Cumulative intensity (Â°C-days)",
       y="Log abundance ratio",
       title="A) Abundance")+
  theme(axis.title.x = element_blank())+
  guides(color=F)
abundance_ratios
```