---
title: "current_weighted_distance"
author: "Shahar Chaikin"
date: "2025-10-10"
output: html_document
---

libraries
```{r}
library(tidyverse)
```

Data
Read yearly current data dating from 1/1/1987-1/1/2022
n: 46.129 w: -6.4959 s: 27.896 e: 37.039
uo = eastward sea water velocity (m/s)
vo =northward sea water velocity (m/s)

```{r}
currents=stars::read_ncdf(
  "copernicus_data_by_hexagon/currents/cmems_mod_med_phy-cur_my_4.2km_P1Y-m_1760095046500.nc") %>% 
  as_tibble() %>% 
  drop_na %>% 
  mutate(h3_id=h3jsr::point_to_cell(
    input = sf::st_as_sf(.,
                         coords = c("longitude", "latitude"),
                         crs = 4326),
    res = 3))

#Used h3 for analysis
analysis_h3=read_rds("filtered_data_before_first_record_dt_sst_meff.rds")

currents_used=currents %>% 
  filter(h3_id%in%unique(analysis_h3$h3_id))

#write_rds(currents,"currents.rds")
#write_rds(currents_used,"currents_used.rds")
```

Median current velocity per h3
```{r}
currents_used_median=currents_used %>% 
  group_by(h3_id) %>% 
  summarise(median_eastern=median(as.numeric(uo)),
            median_northern=median(as.numeric(vo))) 
  # mutate(# Calculate the net speed magnitude (scalar)
  #   net_speed_S = sqrt(median_eastern^2 + median_northern^2),
  #   # 2. Define Cost (C)
  #   # The cost is the inverse of the net speed
  #   current_cost_C = 1 / (net_speed_S))
```

plot eastern
```{r eval=FALSE, include=FALSE}
currents_used_median_e_sf <- currents_used %>%
  group_by(h3_id) %>%
  summarise(median_eastern=median(as.numeric(uo))) %>% 
  # Pass the entire data frame and specify the H3 column name
  h3jsr::cell_to_polygon(
    input = .,               # '.' refers to the incoming data frame
    simple = FALSE           # Recommended for a tidy output
  ) %>%
  # The output is now a proper sf object, so st_set_crs works
  sf::st_set_crs(4326)

# 3. Get Mediterranean Land Boundaries for Context
# Function from rnaturalearth
world <-rnaturalearth:: ne_countries(scale = "large", returnclass = "sf")

# 4. Create the ggplot map
eastern_map <- ggplot() +
    # Plot the H3 Hexagons (your data)
  geom_sf(
    data = currents_used_median_e_sf,
    # Fills the hexagons based on the 'sources' count
    aes(fill = median_eastern), 
    color = "black",     
    linewidth = 0.1,     
    alpha = 0.8          
  ) +
  # Add land boundaries first 
  geom_sf(data = world, fill = "antiquewhite", color = "black", linewidth = 0.1) +
  # Customize the color scale (from ggplot2 / viridis package, which tidyverse uses)
  scale_fill_viridis_c(
    name = "Eastward velocity (m/s)",
    option = "turbo"
  ) +
  # Set the map extent to focus on the Mediterranean Sea
  coord_sf(
    xlim = c(-6, 38),   
    ylim = c(26, 48),  
    expand = FALSE
  ) +
  # Apply a clean theme and labels
  labs(
    title = "A) Median eastern",
    x = "Longitude",
    y = "Latitude"
  ) +
  theme_bw() +
  theme(
# --- CHANGE IS HERE ---
 # Moves the legend inside the plot using (x, y) coordinates
legend.position = c(0.22, 0.17),
# Optional: Makes the legend background transparent
legend.background = element_rect(fill = "transparent", color = NA),
legend.key.size = unit(0.25, "cm"),
panel.grid.major = element_line(color = "skyblue", linewidth = 0.2),
    panel.background = element_rect(fill = "skyblue", color = NA) 
  )
eastern_map
```

plot northern
```{r eval=FALSE, include=FALSE}
currents_used_median_n_sf <- currents_used %>%
  group_by(h3_id) %>%
  summarise(median_northern=median(as.numeric(vo))) %>% 
  # Pass the entire data frame and specify the H3 column name
  h3jsr::cell_to_polygon(
    input = .,               # '.' refers to the incoming data frame
    simple = FALSE           # Recommended for a tidy output
  ) %>%
  # The output is now a proper sf object, so st_set_crs works
  sf::st_set_crs(4326)

# 3. Get Mediterranean Land Boundaries for Context
# Function from rnaturalearth
world <-rnaturalearth:: ne_countries(scale = "large", returnclass = "sf")

# 4. Create the ggplot map
northern_map <- ggplot() +
    # Plot the H3 Hexagons (your data)
  geom_sf(
    data = currents_used_median_n_sf,
    # Fills the hexagons based on the 'sources' count
    aes(fill = median_northern), 
    color = "black",     
    linewidth = 0.1,     
    alpha = 0.8          
  ) +
  # Add land boundaries first 
  geom_sf(data = world, fill = "antiquewhite", color = "black", linewidth = 0.1) +
  # Customize the color scale (from ggplot2 / viridis package, which tidyverse uses)
  scale_fill_viridis_c(
    name = "Northward velocity (m/s)",
    option = "turbo"
  ) +
  # Set the map extent to focus on the Mediterranean Sea
  coord_sf(
    xlim = c(-6, 38),   
    ylim = c(26, 48),  
    expand = FALSE
  ) +
  # Apply a clean theme and labels
  labs(
    title = "B) Median Northern",
    x = "Longitude",
    y = "Latitude"
  ) +
  theme_bw() +
  theme(
# --- CHANGE IS HERE ---
 # Moves the legend inside the plot using (x, y) coordinates
legend.position = c(0.22, 0.17),
# Optional: Makes the legend background transparent
legend.background = element_rect(fill = "transparent", color = NA),
legend.key.size = unit(0.25, "cm"),
panel.grid.major = element_line(color = "skyblue", linewidth = 0.2),
    panel.background = element_rect(fill = "skyblue", color = NA) 
  )
northern_map
```

Export
```{r eval=FALSE, include=FALSE}
e_n_maps=gridExtra::grid.arrange(
  eastern_map,
  northern_map,
  ncol = 1,
  nrow=2,
  layout_matrix = rbind(c(1),
                        c(2)))

e_n_maps
ggsave(filename ="e_n_maps.png" ,plot =e_n_maps ,device = "jpeg",units = "cm",width = 20,height = 20)
```

#1) candidate index - Directional Current Index (DCI)
Higher scores for hexagons with current directionality that aligns with the bearign from the Suez Canal mouth to the target hexagon.

 Step 1: Data Preparation and Centroid Calculation
```{r}
library(geosphere) # Good for calculating distances on a sphere

# The Suez Canal Source H3 ID
SOURCE_H3 <- "833e65fffffffff"

# --- Assuming 'currents_used_median' has columns: h3_id, median_eastern (uo), median_northern (vo) ---

# 1. Calculate Centroids for all hexagons
# The h3_to_point function gives the center latitude and longitude
h3_centroids <- currents_used_median %>%
  mutate(
    coords = h3jsr::cell_to_point(h3_id),
    lat = sapply(coords, function(x) x[2]),
    lon = sapply(coords, function(x) x[1]),
  ) %>%
  select(-coords)

# 2. Extract Source Coordinates - manually is better
# source_coords <- h3_centroids %>%
#   filter(h3_id == SOURCE_H3) %>%
#   select(lon, lat)

SOURCE_LAT <- 31.332367
SOURCE_LON <- 32.385074 
```
 
 Step 2: Calculate Dispersal Vector (D) and Euclidean Distance
```{r}
dci_data <- h3_centroids %>%
  rowwise() %>%
  mutate(
    # 1. Calculate Simple Euclidean Distance (d_Euclidean, in meters)
    d_Euclidean = geosphere::distm(c(SOURCE_LON, SOURCE_LAT), c(lon, lat), fun = geosphere::distHaversine),
    
    # 2. Calculate Bearing (direction of travel from source to target, in degrees)
    # This defines the direction of the Dispersal Vector (D)
    bearing_deg = geosphere::bearing(c(SOURCE_LON, SOURCE_LAT), c(lon, lat))
  ) %>%
  ungroup() %>%
  # Convert distance from meters to kilometers for a more manageable scale
  mutate(d_Euclidean_km = d_Euclidean / 1000) %>% 
  select(-d_Euclidean)
```
 
 Step 3: Calculate Current Assistance (Dot Product)
calculating the dot product to find the component of the current that aids (or opposes) travel along the direct line to the source.

Convert Bearing to Radians and Unit Vector: The bearing (direction of D) must be converted from degrees to radians, and then split into x (East/West) and y (North/South) components.
V = net Current Vector (V):
Calculate Current Assistance (V⋅D):
```{r}
dci_data_step_3 <- dci_data %>%
  rowwise() %>%
  mutate(
    # Convert bearing to radians (required for trigonometric functions)
    bearing_rad = bearing_deg * pi / 180,
    
    # 1. Calculate Dispersal Vector components (Dx and Dy)
    # The x-component is sine (East/West), y-component is cosine (North/South)
    # Note: Longitude/X is scaled by cos(latitude) for accuracy, but we use simple trig for the unit vector D
    Dx = sin(bearing_rad), # East-West component of the Dispersal path
    Dy = cos(bearing_rad), # North-South component of the Dispersal path
    
    # 2. Calculate Current Assistance (Dot Product: V . D)
    # Assistance = (uo * Dx) + (vo * Dy)
    Current_Assistance = (median_eastern * Dx) + (median_northern * Dy),
    
    # 3. Calculate Directional Current Index (DCI)
    # DCI = Current Assistance * Distance (km)
    DCI = Current_Assistance * d_Euclidean_km
  ) %>%
  ungroup() %>% 
  rowwise() %>%
  mutate(
    # Calculate the Distance Decay Penalty factor (the 0.01 or Lambda is a decay parameter that I can adjust)
#     λ (Decay Parameter): A positive constant that determines how quickly the resistance increases with distance.
# 
# Large λ: Fast decay (high resistance).
# 
# Small λ: Slow decay (low resistance).
    Distance_Decay_Penalty = exp(-0.001 * d_Euclidean_km),
    
    # Calculate the Distance-Penalized DCI (DCI_P)
    DCI_P = Current_Assistance * Distance_Decay_Penalty
  ) %>%
  ungroup()

#write.csv(dci_data_step_3,"dci_index.csv",row.names = F)

```

Explanation paragraph:
To accurately account for the non-random spatial spread of non-indigenous species (NIS) following the prevalent oceanographic regime, we developed a novel predictor variable: the Distance-Penalized Directional Current Index (DCI P). This index was incorporated into the GLMM to isolate the effect of physical dispersal mechanisms from general time trends. The DCI P was calculated for each h3 hexagon as the product of the Current Assistance and an Exponential Distance Decay Penalty. The Current Assistance component was derived from the dot product (V⋅D), where V is the local median current velocity vector (uo and vo) and D is the unit vector defining the straight-line path from the Suez Canal source hexagon to the target hexagon. This dot product yields a value in m/s that is positive when the local current assists travel toward the target, and negative when the current opposes it. This assistance value was then penalized using an exponential decay function, e (−λ×Distance km ) , where Distance km is the Euclidean distance from the source. This penalty ensures that the index heavily weights against long-distance dispersal, reflecting the inherent ecological resistance of colonization over great distances. Consequently, a positive DCI P value indicates a hexagon is highly favorable for colonization (supported by current and close to the source), while a negative DCI P  value indicates strong opposition from the current, typically observed in westward locations against the prevailing counter-clockwise circulation.




Interpretation of Directional Current Index (DCI)
Positive DCI: The hexagon's current field generally aligns with the straight-line path from the Suez Canal. This represents a favorable location for spread. (Expected for areas along the Levantine coast).

Negative DCI: The hexagon's current field generally opposes the straight-line path from the Suez Canal. This represents an unfavorable location for spread. (Expected for areas westward of the canal, like Libya).

Plot DCI
```{r}
dci_data_step_3_sf <- dci_data_step_3 %>%
  select(h3_id,DCI) %>% 
  # Pass the entire data frame and specify the H3 column name
  h3jsr::cell_to_polygon(
    input = .,               # '.' refers to the incoming data frame
    simple = FALSE           # Recommended for a tidy output
  ) %>%
  # The output is now a proper sf object, so st_set_crs works
  sf::st_set_crs(4326)

# 3. Get Mediterranean Land Boundaries for Context
# Function from rnaturalearth
world <-rnaturalearth:: ne_countries(scale = "large", returnclass = "sf")

# 4. Create the ggplot map
dci_map <- ggplot() +
    # Plot the H3 Hexagons (your data)
  geom_sf(
    data = dci_data_step_3_sf,
    # Fills the hexagons based on the 'sources' count
    aes(fill = DCI), 
    color = "black",     
    linewidth = 0.1,     
    alpha = 0.8          
  ) +
  # Add land boundaries first 
  geom_sf(data = world, fill = "antiquewhite", color = "black", linewidth = 0.1) +
  # Customize the color scale (from ggplot2 / viridis package, which tidyverse uses)
  scale_fill_viridis_c(
    name = "Directional Current Index",
    option = "turbo"
  ) +
  # Set the map extent to focus on the Mediterranean Sea
  coord_sf(
    xlim = c(-6, 38),   
    ylim = c(26, 48),  
    expand = FALSE
  ) +
  # Apply a clean theme and labels
  labs(
    title = "Directional Current Index (km X m/s)",
    x = "Longitude",
    y = "Latitude"
  ) +
  theme_bw() +
  theme(
# --- CHANGE IS HERE ---
 # Moves the legend inside the plot using (x, y) coordinates
legend.position = c(0.22, 0.17),
# Optional: Makes the legend background transparent
legend.background = element_rect(fill = "transparent", color = NA),
legend.key.size = unit(0.25, "cm"),
panel.grid.major = element_line(color = "skyblue", linewidth = 0.2),
    panel.background = element_rect(fill = "skyblue", color = NA) 
  )
dci_map

# The map of the Directional Current Index (DCI) shows the cumulative current assistance for any given hexagon (h3_id) along the straight-line path from the Suez Canal source.
# 
# The DCI calculation is:
# 
# DCI=Current_Assistance×Distance 
# km
# ​
#  
# 1. The Core Result
# Warm Colors (Positive DCI): Areas like the Levantine Basin (Israel, Lebanon) and the Aegean Sea show high positive values (up to ∼200 km⋅m/s). This means that both the current is supportive and the distance travelled is substantial. The counter-clockwise current is physically facilitating the spread to these far-field locations.
# 
# Cool Colors (Negative DCI): Areas west of the Suez Canal, particularly along the North African coast, show negative values (down to ∼−300 km⋅m/s). This indicates that while the distance travelled is substantial, the currents actively oppose the movement, making colonization highly unlikely.
# 
# Near Zero Colors (Green/Yellow): Areas very close to the source or areas where the current is either weak or flowing perpendicular to the straight-line path.
# 
# 2. How the DCI Accounts for Distance
# The DCI does not just account for distance; it uses distance to weight the velocity effect.
# 
# The DCI prevents a common statistical error: If you just used Current_Assistance (m/s), you would assume a hexagon near the source with a fast current has the same impact as one 1000 km away. By multiplying by distance, the DCI correctly identifies that a sustained, assisting current over a long distance is the most significant factor driving successful large-scale colonization.
# 
# In your GLMM, a strong positive coefficient on scale(DCI) will validate your core hypothesis: The colonization probability decreases proportionally to the cumulative cost/difficulty of travel imposed by the ocean currents.
```

Plot DCI_p
```{r}
dci_data_p_sf <- dci_data_step_3 %>%
  select(h3_id,DCI_P) %>% 
  # Pass the entire data frame and specify the H3 column name
  h3jsr::cell_to_polygon(
    input = .,               # '.' refers to the incoming data frame
    simple = FALSE           # Recommended for a tidy output
  ) %>%
  # The output is now a proper sf object, so st_set_crs works
  sf::st_set_crs(4326)

dci_p_map <- ggplot() +
    # Plot the H3 Hexagons (your data)
  geom_sf(
    data = dci_data_p_sf,
    # Fills the hexagons based on the 'sources' count
    aes(fill = DCI_P), 
    color = "black",     
    linewidth = 0.1,     
    alpha = 0.8          
  ) +
  # Add land boundaries first 
  geom_sf(data = world, fill = "antiquewhite", color = "black", linewidth = 0.1) +
  # Customize the color scale (from ggplot2 / viridis package, which tidyverse uses)
  scale_fill_viridis_c(
    name = "Directional Current Index (penalized)",
    option = "turbo"
  ) +
  # Set the map extent to focus on the Mediterranean Sea
  coord_sf(
    xlim = c(-6, 38),   
    ylim = c(26, 48),  
    expand = FALSE
  ) +
  # Apply a clean theme and labels
  labs(
    title = "Directional Current Index penalized (m/s)",
    x = "Longitude",
    y = "Latitude"
  ) +
  theme_bw() +
  theme(
# --- CHANGE IS HERE ---
 # Moves the legend inside the plot using (x, y) coordinates
legend.position = c(0.22, 0.17),
# Optional: Makes the legend background transparent
legend.background = element_rect(fill = "transparent", color = NA),
legend.key.size = unit(0.25, "cm"),
panel.grid.major = element_line(color = "skyblue", linewidth = 0.2),
    panel.background = element_rect(fill = "skyblue", color = NA) 
  )
dci_p_map
ggsave(filename ="dci_p_map.png" ,plot =dci_p_map ,device = "jpeg",units = "cm",width = 20,height = 12)
```



#2) Hydrographic Distance (HD)

